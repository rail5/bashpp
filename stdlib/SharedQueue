#!/usr/bin/env bpp

# Copyright (C) 2025 Andrew S. Rightenburg
# GNU General Public License v3.0
# This file is part of the Bash++ Standard Library.

@include_once "SharedObject"

if ! command -v wc &> /dev/null; then
	>&2 echo "Bash++: SharedQueue requires the 'wc' command to be available."
	exit 1
fi
if ! command -v base64 &> /dev/null; then
	>&2 echo "Bash++: SharedQueue requires the 'base64' command to be available."
	exit 1
fi
if ! command -v sed &> /dev/null; then
	>&2 echo "Bash++: SharedQueue requires the 'sed' command to be available."
	exit 1
fi

## Queue which can be shared between multiple concurrent processes
##
## Reads and writes are atomic and concurrency-safe.
## The queue can be encrypted for security.
## Internally, it uses the file system to store the queue state.
@class SharedQueue : SharedObject {
	## Echo the number of elements in the queue.
	## @outputs The number of elements in the queue.
	@virtual @public @method size {
		@this._lock
		wc -l 2>/dev/null < @this.object_file || echo 0
		@this._unlock
	}

	## Add a value to the back of the queue.
	## @param value The value to add to the queue.
	@virtual @public @method enqueue value {
		@this.used=1
		@this._lock
		if [[ @this.encrypted -eq 1 ]]; then
			value="@(openssl enc -aes-256-cbc -pbkdf2 -pass pass:@this.encryption_key -a -A <<<"$value")"
		fi
		printf "%s" "$value" | base64 -w0 >> "@this.object_file"
		echo >> "@this.object_file"
		@this._unlock
	}

	## @ignore
	@private @method _get_front {
		local first_line=@(sed -n 1p "@this.object_file" | base64 -d)
		if [[ -z "$first_line" ]]; then
			return 1
		fi

		if [[ @this.encrypted -eq 1 ]]; then
			printf "%s" "$first_line" | openssl enc -d -aes-256-cbc -pbkdf2 -pass pass:@this.encryption_key -a -A
		else
			echo "$first_line"
		fi
	}

	## @ignore
	@private @method _get_back {
		local last_line=@(sed -n '$p' "@this.object_file" | base64 -d)
		if [[ -z "$last_line" ]]; then
			return 1
		fi

		if [[ @this.encrypted -eq 1 ]]; then
			printf "%s" "$last_line" | openssl enc -d -aes-256-cbc -pbkdf2 -pass pass:@this.encryption_key -a -A
		else
			echo "$last_line"
		fi
	}

	## Remove the front element from the queue and echo it.
	## @outputs The value at the front of the queue.
	## @returns 1 if the queue is empty, 0 otherwise.
	@virtual @public @method dequeue {
		@this.used=1
		@this._lock
		@this._get_front
		if [[ $? -ne 0 ]]; then
			@this._unlock
			return 1
		fi
		sed -i.tmp '1d' "@{this.object_file}" && rm -f "@{this.object_file}.tmp"
		@this._unlock
	}

	## Echo the front element of the queue without removing it.
	## @outputs The value at the front of the queue.
	## @returns 1 if the queue is empty, 0 otherwise.
	@virtual @public @method front {
		@this.used=1
		@this._lock
		@this._get_front
		if [[ $? -ne 0 ]]; then
			@this._unlock
			return 1
		fi
		@this._unlock
	}

	## Echo the back element of the queue without removing it.
	## @outputs The value at the back of the queue.
	## @returns 1 if the queue is empty, 0 otherwise.
	@virtual @public @method back {
		@this.used=1
		@this._lock
		@this._get_back
		if [[ $? -ne 0 ]]; then
			@this._unlock
			return 1
		fi
		@this._unlock
	}

	## Clear all elements from the queue.
	@virtual @public @method clear {
		@this._lock
		> "@this.object_file"
		@this._unlock
	}

	## Silently check whether the queue is empty.
	## @outputs nothing
	## @returns 0 if the queue is empty, 1 otherwise.
	@virtual @public @method empty {
		if [[ @this.size -eq 0 ]]; then
			return 0
		else
			return 1
		fi
	}
}
