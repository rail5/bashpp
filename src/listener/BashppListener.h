/**
* Copyright (C) 2025 rail5
* Bash++: Bash with classes
*/

#ifndef SRC_LISTENER_BASHPPLISTENER_H_
#define SRC_LISTENER_BASHPPLISTENER_H_

#include <iostream>
#include <vector>
#include <set>
#include <list>
#include <memory>
#include <stack>
#include <optional>
#include <antlr4-runtime.h>

#include "../antlr/BashppParserBaseListener.h"
#include "ParserRuleContext.h"

class BashppListener;

#include "../bpp_include/bpp_codegen.h"
using code_segment = bpp::code_segment;
using bpp::generate_supershell_code;
using bpp::generate_delete_code;
using bpp::generate_method_call_code;
using bpp::generate_dynamic_cast_code;

#include "../bpp_include/bpp.h"

#include "../syntax_error.h"
#include "../internal_error.h"

#define skip_syntax_errors if (error_thrown) { \
		if (error_context == ctx) { \
			error_thrown = false; \
			error_context = nullptr; \
		} \
		return; \
		}

/**
 * @class BashppListener
 * @brief The main listener class for the Bash++ compiler
 * 
 * This class is the main listener for the Bash++ compiler.
 * This is where the main logic for the compiler is implemented by walking the parse tree generated by the ANTLR parser.
 * 
 * The listener is responsible for generating the compiled Bash code from the parsed Bash++ code.
 * The listener is also responsible for handling errors and warnings.
 * 
 * A brief run-down of how the parse tree works:
 * - The parse tree is a tree representation of the parsed code.
 * - When the parser encounters a new statement, it creates a new node in the parse tree.
 * - If Statement A is inside Statement B, then Statement A is a child of Statement B in the parse tree.
 * - The listener walks the parse tree, visiting each node in the tree in a depth-first manner.
 * - When the listener visits a node, it executes the corresponding function in the listener class.
 *
 * When we enter a node in the parse tree, we execute the enter* function for that node.
 * When we exit a node in the parse tree, we execute the exit* function for that node.
 */
class BashppListener : public BashppParserBaseListener, std::enable_shared_from_this<BashppListener> {
	private:
		/**
		 * @var source_file
		 * @brief Path to the source file being compiled (used for error reporting)
		 */
		std::string source_file;

		bool included = false;

		/**
		 * @var include_paths
		 * @brief A list of paths to search for included files
		 */
		std::shared_ptr<std::vector<std::string>> include_paths = nullptr;

		bool suppress_warnings = false;

		/**
		 * @var included_files
		 * @brief A set of (unique) included files (used for '@include_once' directives)
		 */
		std::shared_ptr<std::set<std::string>> included_files = std::make_shared<std::set<std::string>>();
		BashppListener* included_from = nullptr;

		/**
		 * @var include_stack
		 * @brief A chain of included files, from the main file to the current file (used for error reporting)
		 */
		std::stack<std::string> include_stack;

		/**
		 * @var output_stream
		 * @brief Pointer to the output stream to write the compiled code to
		 */
		std::shared_ptr<std::ostream> code_buffer;
		std::shared_ptr<std::ostream> output_stream;
		std::string output_file;
		bool run_on_exit = false;

		/**
		* @var target_bash_version
		* @brief The target Bash version to compile for (default is 5.2)
		*/
		std::pair<uint16_t, uint16_t> target_bash_version = {5, 2};

		/**
		 * @var arguments
		 * @brief Command-line arguments to pass to the compiled program if run_on_exit is true
		 */
		std::vector<char*> arguments = {};

		std::shared_ptr<bpp::bpp_program> program = std::make_shared<bpp::bpp_program>();

		/**
		 * Context information:
		 * @var in_while_condition: This is set high when we're parsing the *condition* of a while loop
		 * @var current_while_condition: If in_while_condition is true, this points to the relevant while_condition entity
		 * @var in_method: This is set high when we're parsing a method definition
		 * @var in_class: This is set high when we're parsing a class definition
		 * @var in_supershell: This is set high when we're parsing a supershell (i.e., the contents inside '@( ... )')
		 * @var in_bash_function: This is set high when we're parsing a pure-bash function definition
		 *
		 * The last three booleans are especially helpful to determine whether temporary variables can be declared 'local' or not.
		 * Although the compiler always tries to automatically clean up after itself (using 'unset'),
		 * We still prefer to declare temporary variables as 'local' whenever possible, to avoid polluting the global namespace.
		 */

		bool in_while_condition = false;
		std::shared_ptr<bpp::bash_while_condition> current_while_condition = nullptr;
		bool in_method = false;

		bool in_class = false;
		bool in_supershell = false;
		bool in_bash_function = false;

		/**
		 * Context expectations information:
		 * @var can_take_primitive: Whether a primitive value is acceptable in the current context
		 * @var can_take_object: Whether a non-primitive object is acceptable in the current
		 * In the event that a non-primitive object is referenced in a place where only a primitive is acceptable,
		 * The Bash++ spec says that the .toPrimitive method should be called automatically.
		 *
		 * Further:
		 * There are only four cases in which a non-primitive object can be used directly (without conversion to a primitive),
		 * And there is only one case in which a primitive cannot be used directly.
		 *
		 * The four cases in which a non-primitive object can be used directly are:
		 *   1. In @delete statements
		 *   2. In non-primitive copies (rvalue) [the right-hand side of an assignment iff the left-hand was non-primitive]
		 *   3. In non-primitive copies (lvalue) [the left-hand side of an assignment, always]
		 *   4. When preceded by the '&' operator to get the object's address
		 *
		 * The one case in which a primitive cannot be used directly is as the rvalue in a non-primitive assignment.
		 *  I.e., @nonPrimitiveObject="primitive value"
		 *
		 * In **all** other contexts: primitives are acceptable, and non-primitives are unacceptable.
		 */
		bool can_take_primitive = true;
		bool can_take_object = false;

		/**
		 * @var entity_stack
		 * @brief A stack to keep track of the current entity being processed
		 * 
		 * For example, when we encounter a class definition, we push the class onto the entity_stack.
		 * Then, inside that class, when we encounter a method definition, we push the method onto the entity_stack.
		 * Inside that method, when we encounter a value assignment, we push the value assignment onto the entity_stack.
		 * When we're done with the value assignment, we pop it off the entity_stack, so that the method is now at the top of the stack.
		 * When we're done with the method, we pop it off the entity_stack, so that the class is now at the top of the stack.
		 * When we're done with the class, we pop it off the entity_stack, so that the program is now at the top of the stack.
		 */
		std::stack<std::shared_ptr<bpp::bpp_entity>> entity_stack;

		/**
		 * @var replacement_file_contents
		 * @brief This option is used by the language server.
		 * 
		 * The first element is the file path, and the second element is the contents of the file.
		 * 
		 * If set, it tells the listener not to read from the given file path, but instead to use the contents provided.
		 * 
		 * The language server uses this to parse unsaved changes in your editor.
		 */
		std::optional<std::pair<std::string, std::string>> replacement_file_contents;

		std::shared_ptr<bpp::bpp_class> primitive;

		bool error_thrown = false;
		antlr4::ParserRuleContext* error_context = nullptr;

		bool program_has_errors = false;

		#define set_error_context error_thrown = true; error_context = ctx;

		template<class T>
		static constexpr bool dependent_false_v = false;
		
		template<typename Sym>
		void output_syntax_error(Sym* error_ctx, const std::string& msg) {
			if constexpr(std::is_base_of<antlr4::ParserRuleContext, Sym>::value) {
				// A ParserRuleContext has been passed
				int line = static_cast<int>(error_ctx->getStart()->getLine());
				int column = static_cast<int>(error_ctx->getStart()->getCharPositionInLine());
				std::string text = error_ctx->getText();
				print_syntax_error_or_warning(source_file, line, column, text, msg, get_include_stack(), program);
			} else if constexpr(std::is_base_of<antlr4::tree::TerminalNode, Sym>::value) {
				// A token has been passed directly
				antlr4::Token* symbol = error_ctx->getSymbol();
				antlr4::CommonToken* token = dynamic_cast<antlr4::CommonToken*>(symbol);
				int line;
				int column;
				std::string text;
				if (token == nullptr) {
					line = static_cast<int>(symbol->getLine());
					column = static_cast<int>(symbol->getCharPositionInLine());
					text = symbol->getText();
				} else {
					line = static_cast<int>(token->getLine());
					column = static_cast<int>(token->getCharPositionInLine());
					text = token->getText();
				}
				print_syntax_error_or_warning(source_file, line, column, text, msg, get_include_stack(), program);
			} else if constexpr(std::is_base_of<antlr4::Token, Sym>::value) {
				// A symbol has been passed
				int line = static_cast<int>(error_ctx->getLine());
				int column = static_cast<int>(error_ctx->getCharPositionInLine());
				std::string text = error_ctx->getText();
				print_syntax_error_or_warning(source_file, line, column, text, msg, get_include_stack(), program);
			} else {
				static_assert(dependent_false_v<Sym>, "output_syntax_error<Sym>: Sym must be a ParserRuleContext*, TerminalNode*, or Token*.");
			}
			program_has_errors = true;
		}

		#define throw_syntax_error_sym(symbol, msg) \
			output_syntax_error(symbol, msg); \
			set_error_context \
			return;

		#define throw_syntax_error(token, msg) \
			throw_syntax_error_sym(token, msg) \
			set_error_context \
			return;

		#define throw_syntax_error_from_exitRule(token, msg) \
			output_syntax_error(token, msg); \
			return;
		
		#define show_warning_sym(symbol, msg) \
			if (!suppress_warnings) { \
				int line = static_cast<int>(symbol->getLine()); \
				int column = static_cast<int>(symbol->getCharPositionInLine()); \
				std::string text = symbol->getText(); \
				print_syntax_error_or_warning(source_file, line, column, text, msg, get_include_stack(), program, true); \
			}
		
		#define show_warning(token, msg) antlr4::Token* symbol = token->getSymbol(); \
			show_warning_sym(symbol, msg)

	public:

	void set_source_file(std::string source_file);
	void set_include_paths(std::shared_ptr<std::vector<std::string>> include_paths);
	void set_included(bool included);
	void set_included_from(BashppListener* included_from);
	void set_included_files(std::shared_ptr<std::set<std::string>> included_files);
	void set_errors();
	void set_code_buffer(std::shared_ptr<std::ostream> code_buffer);
	void set_output_stream(std::shared_ptr<std::ostream> output_stream);
	void set_output_file(std::string output_file);
	void set_run_on_exit(bool run_on_exit);
	void set_suppress_warnings(bool suppress_warnings);
	void set_target_bash_version(uint16_t major, uint16_t minor);
	void set_arguments(std::vector<char*> arguments);

	void set_replacement_file_contents(const std::string& file_path, const std::string& contents);

	std::shared_ptr<bpp::bpp_program> get_program();
	std::shared_ptr<std::set<std::string>> get_included_files();
	std::stack<std::string> get_include_stack();

	std::shared_ptr<bpp::bpp_code_entity> latest_code_entity();

	void enterProgram(BashppParser::ProgramContext *ctx) override;
	void exitProgram(BashppParser::ProgramContext *ctx) override;

	void enterInclude_statement(BashppParser::Include_statementContext *ctx) override;
	void exitInclude_statement(BashppParser::Include_statementContext *ctx) override;

	void enterClass_definition(BashppParser::Class_definitionContext *ctx) override;
	void exitClass_definition(BashppParser::Class_definitionContext *ctx) override;

	void enterMember_declaration(BashppParser::Member_declarationContext *ctx) override;
	void exitMember_declaration(BashppParser::Member_declarationContext *ctx) override;

	void enterObject_instantiation(BashppParser::Object_instantiationContext *ctx) override;
	void exitObject_instantiation(BashppParser::Object_instantiationContext *ctx) override;

	void enterPointer_declaration(BashppParser::Pointer_declarationContext *ctx) override;
	void exitPointer_declaration(BashppParser::Pointer_declarationContext *ctx) override;

	void enterValue_assignment(BashppParser::Value_assignmentContext *ctx) override;
	void exitValue_assignment(BashppParser::Value_assignmentContext *ctx) override;

	void enterMethod_definition(BashppParser::Method_definitionContext *ctx) override;
	void exitMethod_definition(BashppParser::Method_definitionContext *ctx) override;

	void enterConstructor_definition(BashppParser::Constructor_definitionContext *ctx) override;
	void exitConstructor_definition(BashppParser::Constructor_definitionContext *ctx) override;

	void enterDestructor_definition(BashppParser::Destructor_definitionContext *ctx) override;
	void exitDestructor_definition(BashppParser::Destructor_definitionContext *ctx) override;

	void enterSelf_reference(BashppParser::Self_referenceContext *ctx) override;
	void exitSelf_reference(BashppParser::Self_referenceContext *ctx) override;

	void enterSelf_reference_as_lvalue(BashppParser::Self_reference_as_lvalueContext *ctx) override;
	void exitSelf_reference_as_lvalue(BashppParser::Self_reference_as_lvalueContext *ctx) override;

	void enterStatement(BashppParser::StatementContext *ctx) override;
	void exitStatement(BashppParser::StatementContext *ctx) override;

	void enterClass_body_statement(BashppParser::Class_body_statementContext *ctx) override;
	void exitClass_body_statement(BashppParser::Class_body_statementContext *ctx) override;

	void enterGeneral_statement(BashppParser::General_statementContext *ctx) override;
	void exitGeneral_statement(BashppParser::General_statementContext *ctx) override;

	void enterObject_assignment(BashppParser::Object_assignmentContext *ctx) override;

	void exitObject_assignment(BashppParser::Object_assignmentContext *ctx) override;

	void enterPointer_dereference(BashppParser::Pointer_dereferenceContext *ctx) override;
	void exitPointer_dereference(BashppParser::Pointer_dereferenceContext *ctx) override;

	void enterObject_address(BashppParser::Object_addressContext *ctx) override;
	void exitObject_address(BashppParser::Object_addressContext *ctx) override;

	void enterObject_reference(BashppParser::Object_referenceContext *ctx) override;
	void exitObject_reference(BashppParser::Object_referenceContext *ctx) override;

	void enterObject_reference_as_lvalue(BashppParser::Object_reference_as_lvalueContext *ctx) override;
	void exitObject_reference_as_lvalue(BashppParser::Object_reference_as_lvalueContext *ctx) override;

	void enterNullptr_ref(BashppParser::Nullptr_refContext *ctx) override;
	void exitNullptr_ref(BashppParser::Nullptr_refContext *ctx) override;

	void enterNew_statement(BashppParser::New_statementContext *ctx) override;
	void exitNew_statement(BashppParser::New_statementContext *ctx) override;

	void enterDelete_statement(BashppParser::Delete_statementContext *ctx) override;
	void exitDelete_statement(BashppParser::Delete_statementContext *ctx) override;

	void enterDynamic_cast_statement(BashppParser::Dynamic_cast_statementContext *ctx) override;
	void exitDynamic_cast_statement(BashppParser::Dynamic_cast_statementContext *ctx) override;

	void enterDynamic_cast_target(BashppParser::Dynamic_cast_targetContext *ctx) override;
	void exitDynamic_cast_target(BashppParser::Dynamic_cast_targetContext *ctx) override;

	void enterTypeof_statement(BashppParser::Typeof_statementContext *ctx) override;
	void exitTypeof_statement(BashppParser::Typeof_statementContext *ctx) override;

	void enterSupershell(BashppParser::SupershellContext *ctx) override;
	void exitSupershell(BashppParser::SupershellContext *ctx) override;

	void enterSubshell(BashppParser::SubshellContext *ctx) override;
	void exitSubshell(BashppParser::SubshellContext *ctx) override;

	void enterDeprecated_subshell(BashppParser::Deprecated_subshellContext *ctx) override;
	void exitDeprecated_subshell(BashppParser::Deprecated_subshellContext *ctx) override;

	void enterBash_arithmetic(BashppParser::Bash_arithmeticContext *ctx) override;
	void exitBash_arithmetic(BashppParser::Bash_arithmeticContext *ctx) override;

	void enterString(BashppParser::StringContext *ctx) override;
	void exitString(BashppParser::StringContext *ctx) override;

	void enterSinglequote_string(BashppParser::Singlequote_stringContext *ctx) override;
	void exitSinglequote_string(BashppParser::Singlequote_stringContext *ctx) override;

	void enterParameter(BashppParser::ParameterContext *ctx) override;
	void exitParameter(BashppParser::ParameterContext *ctx) override;

	void enterOther_statement(BashppParser::Other_statementContext *ctx) override;
	void exitOther_statement(BashppParser::Other_statementContext *ctx) override;

	void enterRaw_rvalue(BashppParser::Raw_rvalueContext *ctx) override;
	void exitRaw_rvalue(BashppParser::Raw_rvalueContext *ctx) override;

	void enterArray_value(BashppParser::Array_valueContext *ctx) override;
	void exitArray_value(BashppParser::Array_valueContext *ctx) override;

	void enterArray_index(BashppParser::Array_indexContext *ctx) override;
	void exitArray_index(BashppParser::Array_indexContext *ctx) override;

	void enterBash_if_statement(BashppParser::Bash_if_statementContext *ctx) override;
	void exitBash_if_statement(BashppParser::Bash_if_statementContext *ctx) override;

	void enterBash_if_root_branch(BashppParser::Bash_if_root_branchContext *ctx) override;
	void exitBash_if_root_branch(BashppParser::Bash_if_root_branchContext *ctx) override;

	void enterBash_if_else_branch(BashppParser::Bash_if_else_branchContext *ctx) override;
	void exitBash_if_else_branch(BashppParser::Bash_if_else_branchContext *ctx) override;

	void enterBash_if_condition(BashppParser::Bash_if_conditionContext *ctx) override;
	void exitBash_if_condition(BashppParser::Bash_if_conditionContext *ctx) override;

	void enterBash_case_statement(BashppParser::Bash_case_statementContext *ctx) override;
	void exitBash_case_statement(BashppParser::Bash_case_statementContext *ctx) override;

	void enterBash_case_pattern(BashppParser::Bash_case_patternContext *ctx) override;
	void exitBash_case_pattern(BashppParser::Bash_case_patternContext *ctx) override;

	void enterBash_case_pattern_header(BashppParser::Bash_case_pattern_headerContext *ctx) override;
	void exitBash_case_pattern_header(BashppParser::Bash_case_pattern_headerContext *ctx) override;

	void enterBash_while_loop(BashppParser::Bash_while_loopContext *ctx) override;
	void exitBash_while_loop(BashppParser::Bash_while_loopContext *ctx) override;

	void enterBash_while_condition(BashppParser::Bash_while_conditionContext *ctx) override;
	void exitBash_while_condition(BashppParser::Bash_while_conditionContext *ctx) override;

	void enterBash_for_loop(BashppParser::Bash_for_loopContext *ctx) override;
	void exitBash_for_loop(BashppParser::Bash_for_loopContext *ctx) override;

	void enterBash_for_header(BashppParser::Bash_for_headerContext *ctx) override;
	void exitBash_for_header(BashppParser::Bash_for_headerContext *ctx) override;

	void enterBash_function(BashppParser::Bash_functionContext *ctx) override;
	void exitBash_function(BashppParser::Bash_functionContext *ctx) override;

	void enterHeredoc(BashppParser::HeredocContext *ctx) override;
	void exitHeredoc(BashppParser::HeredocContext *ctx) override;

	void enterHeredoc_header(BashppParser::Heredoc_headerContext *ctx) override;
	void exitHeredoc_header(BashppParser::Heredoc_headerContext *ctx) override;

	void enterExtra_statement(BashppParser::Extra_statementContext *ctx) override;
	void exitExtra_statement(BashppParser::Extra_statementContext *ctx) override;

	void enterTerminal_token(BashppParser::Terminal_tokenContext *ctx) override;
	void exitTerminal_token(BashppParser::Terminal_tokenContext *ctx) override;

};

#endif // SRC_LISTENER_BASHPPLISTENER_H_
