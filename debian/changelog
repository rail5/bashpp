bpp (0.7.1) unstable; urgency=medium

  * Compile with C++23 standard
  * bpp-lsp: Eliminate deadlock potential in ProgramPool
    Restrict ourselves to only one mutex, and use atomic operations on
    the snapshot state instead of relying on a secondary mutex which
    could otherwise potentially cause deadlock
  * bpp-lsp: Bug fix: avoid re-parsing twice
  * docs: Cleaned up synopsis on manual page for 'typeof'

 -- rail5 <andrew@rail5.org>  Tue, 19 Aug 2025 23:48:06 +0800

bpp (0.7.0) unstable; urgency=medium

  * bpp: Added typeof operator: Returns a pointer's class name as a
    string
  * Dynamic casts: return nonzero exit code if the cast fails under any
    circumstances
  * bpp: Allow dynamic_casts to resolve the target class dynamically at
    runtime
    With this update:
    - @dynamic_cast<$shell_var> and @dynamic_cast<@object.reference> are
    now valid syntax
    - If a shell variable or object reference are given as the target
    'cast-to' class, the compiler will expect to resolve the class type
    at runtime
    - @dynamic_cast<ClassName> is still absolutely valid syntax,
    however, ClassName being invalid will no longer result in a syntax
    error, but will instead give a warning that 'ClassName' does not
    refer to any known class and that the cast may fail at runtime
  * Error reporting overhaul:  Better and more conscious UTF8 handling
    Removed the 'position_unknown' checks; we no longer have to deal
    with unknown positions now that we're not relying on ANTLR's built-
    in position tracking
    Separation of concerns: moved padding, etc, utf8 procedures to
    helper functions rather than complicating things by inlining
    everything
  * Bug fix in entity resolution: Declare all temporary variables local
    if possible
    If we're inside a class, a supershell, or bash function, it's
    possible for us to declare all temporary variables 'local', and we
    absolutely should
    This fixes a bug with nested object references. For example,
    @this.member=@(echo @this.member and then some)
    If the temporary variables necessary to access this.member are not
    declared local, then:
    - The pre-code necessary to access this.member precedes that
    assignment statement
    - Then, we enter the supershell in the rvalue of the assignment
    statement, which also contains a reference to this.member
    - So, once again we generate the pre-code necessary to access it, we
    access it,
    - AND THEN we execute the post-code necessary to clear the memory
    - That memory having been cleared, we return from the supershell
    context to the broader assignment statement
    And we find that we no longer know where to put the rvalue.
    The variables which told us how to access this.member have been
    cleared from inside the supershell.
    If we declare all temporary variables local however, then the pre-
    and post-code within the supershell is entirely isolated from the
    pre- and post-code of the surrounding assignment statement.
  * STL: Added Typed versions of arrays, stacks and queues
    With our new dynamic cast semantics permitting runtime
    evaluation of the target (casted) type, runtime type restrictions
    become enforceable and typed containers such as these become
    possible
  * STL: Added TypedShared classes: Shared (concurrency-safe) data
    structures with runtime type enforcement on their elements
  * bpp-lsp: Wrap program parsing in try-catch
    No need to crash if there's a ParseCancellationException etc.
    The lexer & parser still need a full rewrite.
  * bpp-lsp: ProgramPool: Verify parsing was successful before changing
    pool state
    This prevents crashes which may come from storing 'nullptr' parse
    results in the program pool's state, and later (unthinkingly) using
    them as if they were valid pointers. It also prevents us from losing
    diagnostic information about programs which have been parsed, which
    have also undergone incomplete updates that can't yet be fully
    re-parsed.
  * bpp-lsp: Keep state AND snapshot of state
    This eliminates any slight possibility for race conditions, where
    one thread may jump the queue and access an element of the
    ProgramPool's state while another thread is simultaneously modifying
    it

 -- rail5 <andrew@rail5.org>  Mon, 18 Aug 2025 22:45:57 +0800

bpp (0.6.2) unstable; urgency=medium

  * Error reporting: Highlight error string in red & underline
    Unified output_syntax_error(varied types, message) to a
    single templated function
    Assign syntax error position to object_assignment ctx rather than
    a specific token
  * Bug fix: Object instantiations: inherit current class from context
  * Bug fix: Protect against primitive value assignments in object
    instantiations
  * bpp-lsp: Use libfrozen-dev to make request/notification handler maps
    constexpr

 -- rail5 <andrew@rail5.org>  Sun, 10 Aug 2025 20:05:37 +0800

bpp (0.6.1) unstable; urgency=medium

  * Lexer: handle position tracking with potential (as yet
    unimplemented) multi-line tokens
    This also fixes a bug in position tracking re: escaped newlines
    Our previous (naive) procedure was simply to assume that if a newline
    was emitted, it was as its own independent token with no other content
    Therefore we just compared token->getText() to '\n'
    But escaped newlines were emitted as "\\n", which meant that we weren't
    properly tracking source code position data when these were present
    Further, multi-line tokens will very likely be implemented in our
    eternally-pending lexer/parser rewrite, in an effort to more efficiently
    handle strings as statements of arbitrary string_data + occasional
    interpolation sequences like object references, supershells, etc.
  * Docs: Consistent formatting in the compiler manual
  * bpp: More helpful error reporting in object instantations / pointer
    declarations
  * bpp_program: Keep entity maps even if empty for all source files
  * Lexer: No double emits  Double-emits screw up position tracking

 -- rail5 <andrew@rail5.org>  Sat, 02 Aug 2025 00:17:41 +0800

bpp (0.6.0) unstable; urgency=medium

  * bpp: Added --target-bash/-b option
    This option allows you to specify the target Bash version for
    compiled code. If specifying a version >= 5.3, supershells will
    compile to use Bash 5.3's new native supershell implementation
    There is a plan to support compiling to Bash < 4.0, but this has
    not yet been implemented. Default Bash target is 5.2
  * Cleaned up manuals
  * bpp-lsp: Resolve nonprimitive data members of classes
  * bpp-lsp: Fixed code completions when suggesting data members, methods
  * bpp-lsp: Full support for Reference Requests ("Find references")

 -- rail5 <andrew@rail5.org>  Thu, 31 Jul 2025 20:59:21 +0800

bpp (0.5.7) unstable; urgency=medium

  * bpp-lsp: Allow immediate port reuse, set SO_REUSEADDR 
  * bpp-lsp: Renamed port/socket longopts to be more intuitive
  * bpp-lsp: Renamed longopt to match corresponding option in bpp
  * Corrected inaccuracies in the documentation
  * bpp: Track class references in object instantiations, dynamic
    casts, and pointer declarations

 -- rail5 <andrew@rail5.org>  Sat, 26 Jul 2025 13:47:45 +0800

bpp (0.5.6) unstable; urgency=medium

  * Language server: Full support for workspace renaming
  * Language server: resolve_entity_at(): Enable resolution of class
    data members, method definitions, and class definitions
  * Class definitions: Track reference to parent class
  * Language server: Stricter resolve_entity_at()
  * Parser: Track class references in object instantiations, pointer
    declarations, and method parameter declarations 
  * Re-organized the build system

 -- rail5 <andrew@rail5.org>  Fri, 25 Jul 2025 23:30:52 +0800

bpp (0.5.5) unstable; urgency=medium

  * Language server / lexer: UTF16 position encoding support

 -- rail5 <andrew@rail5.org>  Thu, 24 Jul 2025 23:39:12 +0800

bpp (0.5.4) unstable; urgency=medium

  * Language server: Include comments connected with the hovered Entity
    in Hover responses
  * Language server: Syntax highlighting in hover responses via markdown
  * Bug fix: Add the required sentinel to getopt's long options struct
  * Entity resolution: preserve line/column signedness and precision
  * Security: Use std::string operations, never strncat, strncpy

 -- rail5 <andrew@rail5.org>  Thu, 24 Jul 2025 02:34:27 +0800

bpp (0.5.3) unstable; urgency=medium

  * Language server: completions: resolve entity at position *before*
    the '.' completion character
  * Language server: HandleInitialize: Send TextDocumentSyncKind::Full
    explicitly, not a casted numeric value

 -- rail5 <andrew@rail5.org>  Tue, 22 Jul 2025 13:27:54 +0800

bpp (0.5.2) unstable; urgency=medium

  * Created bpp-lsp: A Bash++ language server
    This language server has full support for:
    Go-to-definition, hover text, in-editor diagnostics (errors, etc),
    and completions.
    It is multi-threaded and mostly compliant with the LSP spec.
  * VSCode Extension: Added support for the language server
    If the language server is installed on your system, then by default,
    the VSCode extension will connect to it. If it is not installed, then
    no error messages will be shown.
  * Polished the package's build system
  * Error reporting: More helpful error messages in the case of method
    parameters
  * Error reporting: Manually track lexer token position data
    This fixes a bug in which occasionally an error would be reported for
    a token, and we would not be able to say *where* in the file that
    token was.
  * Bug fix: Emit special lexer tokens for class definition start and end
    Fixes an elusive bug in which occasionally the parser would not
    recognize a class definition
  * Optimization: Abstracted a 'resolve_reference' function for use by
    all 4 object reference rules (rvalue/lvalue, object/self references)

 -- rail5 <andrew@rail5.org>  Mon, 21 Jul 2025 20:18:20 +0800

bpp (0.5.1) unstable; urgency=medium

  * Created abstract resolve_reference function in codegen
    This function will resolve entity references (whether object
    references or self references, rvalues or lvalues) and return a
    pointer to the referenced entity, as well as compiled code necessary
    to access it, debug information about that compiled code (whether
    temporary variables were necessary in the compiled code), and
    optional error information if the reference could not be resolved
    This removes a lot of code duplication in handling references
  * Fixed example code display on spec page for 'super'
  * Error reporting:
    Cast tokens to CommonToken before throwing an error or warning
    This should at least *mostly* eliminate 'Position Unknown' errors
    in our error reporting.
    Manually override ANTLR4's broken token position tracking
    ANTLR4's system routinely returns incorrect values for
    token->getLine() and token->getCharPositionInLine(). This is
    screwing with our error reporting. So we'll just track it ourselves
    in our emit() override.
  * Store an intermediary code buffer between the compiler and the
    output stream
    Do not immediately write code to the output stream.
    In the case of '-o -', this clutters the output when errors are
    present.

 -- rail5 <andrew@rail5.org>  Thu, 17 Jul 2025 15:44:24 +0800

bpp (0.5.0) unstable; urgency=medium

  * Added support for 'super' keyword
    Temporarily switches reference context to the immediate parent class
    of the current object
  * Test suite: Use new SharedVar class from STL for statistics

 -- rail5 <andrew@rail5.org>  Sat, 05 Jul 2025 20:11:19 +0800

bpp (0.4.16) unstable; urgency=medium

  * STL: Added 'SharedVar' class
    Adds support for singular shared (primitive) shell variables between
    multiple concurrent processes

 -- rail5 <andrew@rail5.org>  Fri, 04 Jul 2025 17:01:54 +0800

bpp (0.4.15) unstable; urgency=medium

  * Spec: Fixed whatis entry
  * DPKG: Install STL in libstd-bpp package
  * Distribution bug fix: Store STL files without extensions in source
  * STL: Shared data structures now all inherit from SharedObject base
    class
    SharedObject base class now also provides extended locking
    mechanisms to allow a single process's lock to persist across
    several distinct read-write operations, before being unlocked again
    for other processes to use.
    Calling the .lock method and the .unlock method respectively will
    accomplish this.
  * Behavior change: allow dynamic cast rvalues to be empty/unset
    without throwing an error
    Simply return nullptr in that case
  * Bug fix: Properly identify lvalues within supershells within dynamic
    casts
    Again, the lexer needs to be fully overhauled.
    Work has at least nominally began on this but will take time

 -- rail5 <andrew@rail5.org>  Fri, 04 Jul 2025 12:38:28 +0800

bpp (0.4.12) unstable; urgency=medium

  * Lexer: Properly identify lvalues in conditionals
    Again, a full rewrite of the lexer is sorely needed.
  * Code generation optimization: Auto assign 'this' pointer once and
    only once per method
  * Added spec page on interoperability
  * Added spec page on objects

 -- rail5 <andrew@rail5.org>  Sun, 22 Jun 2025 16:34:05 +0800

bpp (0.4.11) unstable; urgency=medium

  * STL: Added SharedArray class for use by multi-process concurrent
    applications
  * Bug fix: lvalue vs. rvalue identification inside test conditions
    If we see what would ordinarily be a connective (such as || or &&)
    inside a test condition (ie, [[ condition ]] or [ condition ] ),
    then, unlike in the ordinary case for a connective, the next token
    cannot be an lvalue
  * Build system: parallel STL builds
  * Bug fix: Input redirection in bash while loops 
  * STL: Re-added Array class 
  * Bug fix: Multi-value array assignments
    Object assignments in which the rvalue was a decently-populated
    array previously failed and only inserted the first element of
    said array. Obvious oversight, now fixed, and arrays are copied
    in full

 -- rail5 <andrew@rail5.org>  Wed, 18 Jun 2025 16:55:54 +0800

bpp (0.4.10) unstable; urgency=medium

  * Additions to the standard library:
    Added SharedQueue class for concurrent multi-process access to the
    same queue.
    Added SharedStack class for concurrent multi-process access to the
    same stack
    SharedQueue and SharedStack are data structures that are safe to use
    among multiple forked processes concurrently. They use the
    filesystem as a back-end for the stored data.
    Reads and writes are atomic and concurrency-safe.
    The data can be encrypted for security.
    Here is an article about this addition:
    https://log.bpp.sh/2025/06/17/multiprocess-concurrency-shared-data-structures.html

 -- rail5 <andrew@rail5.org>  Tue, 17 Jun 2025 12:03:39 +0800

bpp (0.4.9) unstable; urgency=medium

  * Bug fix: Make static 'inaccessible entity' placeholders inline so
    that each unit shares the same definition
    Note also that this is (AFAIK) a C++17-and-later feature, that
    inlining the definition should result in there being only one
    definition across multiple units
    If we don't do this, scope checks will *always* fail

 -- rail5 <andrew@rail5.org>  Sun, 15 Jun 2025 23:33:01 +0800

bpp (0.4.8) unstable; urgency=medium

  * Bug fix: Identify lvalues after case patterns
    Again, the lexer and parser still need to be rewritten from
    scratch
  * Build system improvement:
    Absolutely every unit compiled independently 

 -- rail5 <andrew@rail5.org>  Sun, 15 Jun 2025 15:18:36 +0800

bpp (0.4.7) unstable; urgency=medium

  * Safer dynamic casting
  * Lexer: Properly determine lvalues v. rvalues in the context of
    two-token bpp commands like dynamic_cast and new
  * Removed dead code
  * Bug fix: Properly handle subshell pre-code and post-code
  * Bug fix: Properly scan the entity stack for the latest code entity
    Now we have a function: BashppListener::latest_code_entity() which
    traverses the entity stack until it finds the most recent code entity
    and returns it.
  * Bug fix: Maintain one global list of includes
    This fixes a particular bug, where, for example:
    File A includes File B using include_once
    File B includes File C using include_once
    We return from parsing File B
    File A includes File C using include_once
    With each file having its own include list, 'C' would've been added
    to B's includes but not A's. So A wouldn't have known not to try
    including it again. Now we have a single global include list, and
    each parse holds a pointer to it
  * Bug fix: Protect against direct system method access
    Object reference rules should block ids with double underscores
  * Bug fix: Allow system methods to be referenced before they're fully
    defined

 -- rail5 <andrew@rail5.org>  Tue, 10 Jun 2025 15:45:53 +0800

bpp (0.4.6) unstable; urgency=medium

  * Bug fix: Allow accessing the class from within the class
    Constructs inside of a class are now capable of referencing that
    class itself in all contexts.
  * Performance: bpp_entity function that are never overridden do
    need to be virtual
  * Runtime: guard against copies between objects of different types
  * Set non-zero exit code if there were compilation errors

 -- rail5 <andrew@rail5.org>  Tue, 10 Jun 2025 01:25:25 +0800

bpp (0.4.5) unstable; urgency=medium

  * Bugfix: do not consume tokens in single quotes if we're in
    mode_quote or mode_heredoc
  * Makefile: respect user's choice if they specify -j on the command line,
    but default to using all available CPU cores if unspecified 
  * Added full_code() function to code_segment struct
    With the hope of preventing the compiler from adding a bunch of extra
    newlines to compiled code

 -- rail5 <andrew@rail5.org>  Sun, 01 Jun 2025 22:18:49 +0800

bpp (0.4.4) unstable; urgency=medium

  * Properly isolate objects declared within shell functions (scope handling)
    By having the parser recognize shell function declarations, we can create
    a code_entity for them. All code entities have their scope handled
    automatically in the compiler. Ie, an object declared within a code
    entity will no longer be accessible once that code entity has been
    popped off the entity stack (only accessible from within), as is
    proper

 -- rail5 <andrew@rail5.org>  Sun, 18 May 2025 15:29:31 +0800

bpp (0.4.3) unstable; urgency=medium

  * Bug fix: Inline object instantiations within methods for scope safety
    When instantiating an object inside of a method, rather than calling
    the class's 'new' function externally, we can inline the contents of
    that 'new' function in order to ensure that the created object exists
    purely within a local scope 
    This fixes a bug with recursive method calls in Bash++, where an
    instantiated object which was not declared as a pointer (and
    therefore did not receive a runtime-randomized allocation from
    'new', but received a deterministic allocation determined at compile-
    time) would be overwritten by subsequent calls to the same method
    which would use the same compile-time-determined address
    It may be better in the long-run to ensure that all created objects
    receive runtime-randomized allocations from 'new' (see #6)
  * Combine single-quoted strings directly in the lexer
    This simplifies the parse tree, and makes for faster parsing by
    taking advantage of the speed of the lexer
  * Updated (and corrected) BASH_VAR token in the lexer

 -- rail5 <andrew@rail5.org>  Wed, 14 May 2025 18:21:18 +0800

bpp (0.4.2) unstable; urgency=medium

  * Error reporting: Report an error when a user tries to declare a non-
    primitive object as a parameter to a method
    In the parser, by making the ASTERISK token optional for parameters,
    this allows us to properly identify mistaken attempts to define
    methods. In the code generator, when we encounter the parameter, once
    we determine it's non-primitive we can verify that the ASTERISK token
    is present. If not, we throw a syntax error, informing the user that
    methods can only accept pointers as parameters, not objects
  * Error reporting: Catch invalid identifiers in the code generator, not
    in the lexer
    By allowing identifiers which contain double-underscores in the lexer,
    we simplify the parse tree, and give ourselves the ability to report
    these errors from the code generator rather than failing to, for
    example, identify an attempt at a class definition as such to begin
    with

 -- rail5 <andrew@rail5.org>  Fri, 09 May 2025 17:13:51 +0800

bpp (0.4.1) unstable; urgency=medium

  * Added language spec manuals to section 3
    You'll find manpages describing the functionality of the language
    such as bpp-new(3) and bpp-dynamic-cast(3), which describe the
    functionality of '@new' and '@dynamic_cast' respectively, or
    bpp-classes(3), which describes the structure of a class in Bash++,
    etc.
    This documentation is also available on the website

 -- rail5 <andrew@rail5.org>  Sat, 03 May 2025 10:01:41 +0800

bpp (0.4.0) unstable; urgency=medium

  * Updated include syntax
    Includes now allow you specify whether each include should be linked
    dynamically or statically, and if dynamically, allows you to
    optionally specify where the compiled library will be found at runtime
    The syntax is still backwards- compatible and the new features are
    optional.
  * Made system __delete function virtual
    This ensures that we'll always call the correct __delete function
    regardless of the compile-time inferred type of the object
  * Rely on generate_delete_code when deleting non-primitive data
    members in classes
    Less code duplication, more reliable, only one place to change things
  * destruct_local_objects: rely on generate_delete_code for
    implementation
  * Better build system
    More idiomatic GNU Makefile, faster re-builds on changes
  * Decoupled code generation functions from the listener class

 -- rail5 <andrew@rail5.org>  Fri, 02 May 2025 20:36:34 +0800

bpp (0.3.8) unstable; urgency=medium

  * Treat constructors and destructors as ordinary methods
    Prior to this, constructors and destructors were treated specially
    Now, they're treated as ordinary methods which are always VIRTUAL
    and PUBLIC. This simplifies things and fixes a few bugs, namely:
    Before this change, instantiating an object of class A, and copying
    its address to a pointer of class B (which is allowed in Bash++),
    and then later calling @delete on the B pointer, would have called
    B's destructor if it had one. This is clearly incorrect behavior
    Ensuring that the destructor is virtual forces this to do a vtable
    lookup, guaranteeing that we call the correct destructor regardless
    of the compile-time inferred type.
    Further, before this change, defining a constructor or destructor
    within a base class would preclude the possibility of implementing a
    separate constructor or destructor in a derived class.
    Now that constructors and destructors follow the rules for ordinary
    methods (and are virtual), no special logic is necessary in order to
    override them in derived classes.
    Base class constructors and destructors are still inherited in
    derived classes by default.
  * Object instantiations:
    Verify that the desired class exists earlier rather than later
    Fixes a segfaulting bug
  * New statements: call constructors before returning the pointer
    Ensure that objects which have not yet been constructed are not
    processed too early

 -- rail5 <andrew@rail5.org>  Wed, 30 Apr 2025 18:44:52 +0800

bpp (0.3.7) unstable; urgency=medium

  * Test-suite: Added test for nonprimitive copies
  * value_assignment: always get address directly from rvalue_object,
    do not infer (fixes bug with nonprimitive copies)
  * Dereference pointers at runtime
    Has strong potential to reduce compiler complexity
  * Make pointer declarations within methods local by default

 -- rail5 <andrew@rail5.org>  Sun, 27 Apr 2025 17:03:09 +0800

bpp (0.3.6) unstable; urgency=medium

  * Method handler: Move sanity checks to entry rule
    This allows us to skip parsing invalid methods
    (non-public toPrimitive, or duplicate method definitions),
    saving time
    Adding the method to the class before parsing its contents
    also allows methods to refer to themselves, which is necessary
    for recursive methods

 -- rail5 <andrew@rail5.org>  Sat, 26 Apr 2025 13:53:57 +0800

bpp (0.3.5) unstable; urgency=medium

  * Proper support for c-style arithmetic Bash for loops
  * More sane handling of bash arithmetic statements
  * Proper support for bash number ranges '{#..#[..#]}' 
  * Compiler source code cleanup:
    Made bpp_method's 'add_object_as_parameter' private
    Externally we should only ever call add_parameter, which should
    determine whether the parameter is nonprimitive on its own

 -- rail5 <andrew@rail5.org>  Fri, 25 Apr 2025 22:41:37 +0800

bpp (0.3.4) unstable; urgency=medium

  * Allow taking the address of an object's method
    Return value of &@object.method should be:
    - A function pointer to the method
    - Plus the object pointer as the method's implicit first parameter
    E.g, 'echo &@object.method' should echo something like
    'bpp__Class__method address__of__object'
  * Incidental bug fix: vTable lookups in rvalue self references.
    Patched by properly using the abstracted generate_method_call_code
    function rather than duplicating its functionality. The duplicate
    code was a relic from before that abstracted function existed and
    should've been noticed and patched out sooner
  * Parser speedup
    Removed left-side ambiguity between member declarations and method
    definitions by enclosing them in a shared parent rule
    A total rewrite of the lexer/parser is almost definitely incoming

 -- rail5 <andrew@rail5.org>  Tue, 22 Apr 2025 14:14:53 +0800

bpp (0.3.3) unstable; urgency=medium

  * Skip comments directly in the lexer
    Significant overall speedup.
    Heavily considering a total rewrite of the ANTLR lexer/parser
  * Made list of protected keywords constexpr
    Improves performance, list doesn't have to be initialized at runtime 

 -- rail5 <andrew@rail5.org>  Wed, 02 Apr 2025 15:28:59 +0800

bpp (0.3.2) unstable; urgency=medium

  * Builds: Only search for dynamic libs if static libs can't be found
  * Run an implicit dynamic cast when a method takes a non-primitive
    argument
  * Abstracted dynamic cast code generation to its own function

 -- rail5 <andrew@rail5.org>  Sat, 22 Mar 2025 15:11:17 +0800

bpp (0.3.1) unstable; urgency=medium

  * Keep object counter in compiler
    This closes #6, although the allocations are not randomized at
    runtime. This decision may be revisited later
    An incidentally necessary change for this fix is that the 'isPtr'
    nonsense from templates.h had to be removed entirely, methods
    internally must accept a pointer as the first argument and no extra
    information, just as in C++ for example

 -- rail5 <andrew@rail5.org>  Wed, 19 Mar 2025 11:46:23 +0800

bpp (0.3.0) unstable; urgency=medium

  * Proper vTable implementation
    This ensures that we call the correct versions of virtual methods
    at runtime. This was planned, but previously unimplemented
  * Added '@dynamic_cast' keyword for runtime type checking,
    @dynamic_cast<Type> @pointer
    Will perform a runtime check to verify the cast is valid, and will
    return @nullptr if invalid.
  * Added -s / --no-warnings option to suppress compiler warnings

 -- rail5 <andrew@rail5.org>  Thu, 06 Mar 2025 17:50:17 +0800

bpp (0.2.8) unstable; urgency=medium

  * Test suite: run tests concurrently
  * Major bug fix: Supershells
    Stupid oversight in previous patch caused us to stop using shm and
    file descriptors altogether
    Using /dev/fd. This directory is not guaranteed by POSIX, but far
    more portable than /proc/self/fd
    This breaks compatibility with MacOS and Haiku
  * Bug fix in pointer declarations: Verify current_datamember isn't
    nullptr before accessing its method
  * Build system: Compile and link separately for faster builds with
    concurrency
  * Bug fix: properly handle assignment prefixes before commands
    The lexer should recognize that in a command like
    'var=val command args'
    'var' and 'command' are both lvalues (as per our unusual definition
    of 'lvalue')
  * Build system: Merged pull request #5 from wishdev/touchups
    Common-sense repository touch-ups. Removing auto-generated header
    file, adding gitignore, improved makefile workflow

 -- rail5 <andrew@rail5.org>  Sat, 01 Mar 2025 14:52:08 +0800

bpp (0.2.7) unstable; urgency=medium

  * Removed 'Array' class from STL
    This functionality is really already served by Bash primitive arrays
    Adding non-primitive object arrays would be nice however
  * Bug fix: We'll always have to dereference a pointer if the first
    object in a reference chain is a pointer
    Object references should still be reworked altogether
  * Added test to verify correct exit codes from run-on-exit
  * Pass compiler path to tests in the test suite
    If we want to run another instance of the compiler from within a test,
    we can access it via the $BPP environment variable
  * Portable solution to the problem with inconsistent WEXITSTATUS
    behavior across different systems
  * Portability: Do not assume the presence of /proc/self

 -- rail5 <andrew@rail5.org>  Mon, 24 Feb 2025 15:24:22 +0800

bpp (0.2.6) unstable; urgency=medium

  * Case patterns: Inherit directly from code entities
  * Code entities: Return line buffers by default in get_pre_code
    and get_post_code
  * Make sure we place the pre- and post- code for case headers and case
    rules in the right places
    Pre/post code for case headers should go before/after the entire
    case statement
    Pre/post code inside case rules should go in the usual places
  * Ensure each assignment temporary rvalue has a unique identifier

 -- rail5 <andrew@rail5.org>  Mon, 17 Feb 2025 02:01:02 +0800

bpp (0.2.5) unstable; urgency=medium

  * Changed a few internal_errors to syntax_errors
    An internal error should only be thrown if we encounter something
    that shouldn't be possible
  * More helpful internal errors
    Provide the text of the parse tree where we hit the internal error
  * Better syntax error reporting
    In some cases, ANTLR mistakenly reports token positions as line 0
    column -1 In those cases, we should say that the position is not
    known to us instead of trying to display that portion of the file

 -- rail5 <andrew@rail5.org>  Sun, 16 Feb 2025 18:01:29 +0800

bpp (0.2.4) unstable; urgency=medium

  * Patch: Properly evaluate supershells before & after while loops
  * -t option should exit early if all we're doing is displaying the
    tokens.

 -- rail5 <andrew@rail5.org>  Sun, 16 Feb 2025 01:09:46 +0800

bpp (0.2.3) unstable; urgency=medium

  * Considerable speed increase
    Attempting to slightly refactor the lexer/parser to remove ambiguity
    and reduce our dependence on ANTLR's lookahead and backtracking

 -- rail5 <andrew@rail5.org>  Sat, 15 Feb 2025 17:34:15 +0800

bpp (0.2.2) unstable; urgency=medium

  * Override add_object within code_entity base class
    Every code entity should be able to add object code, not only add a
    reference to the object internally
    This removes a lot of silly code duplication which took place in
    classes derived from code_entity
    And, incidentally, closes #3
  * Properly parse 'for' loops

 -- rail5 <andrew@rail5.org>  Sat, 15 Feb 2025 13:41:16 +0800

bpp (0.2.1) unstable; urgency=medium

  * Fixed #4:
    Do not emit the 'connective' token in contexts in which the
    connective symbol should be interpreted as a literal
    Also recognize a solitary pipe as a valid connective

 -- rail5 <andrew@rail5.org>  Fri, 14 Feb 2025 16:13:13 +0800

bpp (0.2.0) unstable; urgency=medium

  * Added a small standard library to store common data structures
    This standard library will be provided by the libstd-bpp package
    Which package will be a dependency of bpp
    Standard library has for now: Array, Stack, Queue
  * Added option for dynamic linking (-D) in the compiler
    If dynamic linking is enabled, the code from @include'd files will
    Not be copied into your compiled file, but instead, your compiled
    Program will contain a Bash "source" directive pointing to the
    Compiled version of the dynamically linked library, linking it at
    Runtime.
    If you dynamically link an included file such as:
    /usr/lib/bpp/stdlib/Stack.bpp
    Your compiled program will expect to be able to find at runtime:
    /usr/lib/bpp/stdlib/Stack.sh
  * Added support for angle-bracket includes and compiler include paths
    A Bash++ directive such as @include <file> will scan the include
    Paths for the given file.
    The default include path is /usr/lib/bpp/stdlib
    More include paths can be added with the -I option in the compiler
    Include paths will be searched in the order in which they are added
  * Properly parse Bash while loops
  * @new properly returns a pointer (thanks to supershells)
  * Patch: Ensure methods and datamembers don't share names

 -- rail5 <andrew@rail5.org>  Thu, 13 Feb 2025 19:33:29 +0800

bpp (0.1.1) unstable; urgency=medium

  * Patch: Override get_code methods in bash_if_branch
    The base code_entity version of these methods return empty strings
    for pre-and post-code buffers
    This broke if statements that weren't split across multiple lines,
    and therefore never caused the code buffers to be flushed
  * Patch: Add stray terminal tokens to program

 -- rail5 <andrew@rail5.org>  Wed, 12 Feb 2025 22:25:09 +0800

bpp (0.1) unstable; urgency=medium

  * Initial release
    Bash++ is still considered to be in beta (or alpha, take your pick)
    And is expected to break often and have many bugs.
    Please report any bugs you find to the GitHub issue tracker:
    https://github.com/rail5/bashpp/issues

 -- rail5 <andrew@rail5.org>  Wed, 12 Feb 2025 20:09:39 +0800
