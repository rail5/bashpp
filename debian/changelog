bpp (0.4.3) unstable; urgency=medium

  * Bug fix: Inline object instantiations within methods for scope safety
    When instantiating an object inside of a method, rather than calling
    the class's 'new' function externally, we can inline the contents of
    that 'new' function in order to ensure that the created object exists
    purely within a local scope 
    This fixes a bug with recursive method calls in Bash++, where an
    instantiated object which was not declared as a pointer (and
    therefore did not receive a runtime-randomized allocation from
    'new', but received a deterministic allocation determined at compile-
    time) would be overwritten by subsequent calls to the same method
    which would use the same compile-time-determined address
    It may be better in the long-run to ensure that all created objects
    receive runtime-randomized allocations from 'new' (see #6)
  * Combine single-quoted strings directly in the lexer
    This simplifies the parse tree, and makes for faster parsing by
    taking advantage of the speed of the lexer
  * Updated (and corrected) BASH_VAR token in the lexer

 -- rail5 <andrew@rail5.org>  Wed, 14 May 2025 18:21:18 +0800

bpp (0.4.2) unstable; urgency=medium

  * Error reporting: Report an error when a user tries to declare a non-
    primitive object as a parameter to a method
    In the parser, by making the ASTERISK token optional for parameters,
    this allows us to properly identify mistaken attempts to define
    methods. In the code generator, when we encounter the parameter, once
    we determine it's non-primitive we can verify that the ASTERISK token
    is present. If not, we throw a syntax error, informing the user that
    methods can only accept pointers as parameters, not objects
  * Error reporting: Catch invalid identifiers in the code generator, not
    in the lexer
    By allowing identifiers which contain double-underscores in the lexer,
    we simplify the parse tree, and give ourselves the ability to report
    these errors from the code generator rather than failing to, for
    example, identify an attempt at a class definition as such to begin
    with

 -- rail5 <andrew@rail5.org>  Fri, 09 May 2025 17:13:51 +0800

bpp (0.4.1) unstable; urgency=medium

  * Added language spec manuals to section 3
    You'll find manpages describing the functionality of the language
    such as bpp-new(3) and bpp-dynamic-cast(3), which describe the
    functionality of '@new' and '@dynamic_cast' respectively, or
    bpp-classes(3), which describes the structure of a class in Bash++,
    etc.
    This documentation is also available on the website

 -- rail5 <andrew@rail5.org>  Sat, 03 May 2025 10:01:41 +0800

bpp (0.4.0) unstable; urgency=medium

  * Updated include syntax
    Includes now allow you specify whether each include should be linked
    dynamically or statically, and if dynamically, allows you to
    optionally specify where the compiled library will be found at runtime
    The syntax is still backwards- compatible and the new features are
    optional.
  * Made system __delete function virtual
    This ensures that we'll always call the correct __delete function
    regardless of the compile-time inferred type of the object
  * Rely on generate_delete_code when deleting non-primitive data
    members in classes
    Less code duplication, more reliable, only one place to change things
  * destruct_local_objects: rely on generate_delete_code for
    implementation
  * Better build system
    More idiomatic GNU Makefile, faster re-builds on changes
  * Decoupled code generation functions from the listener class

 -- rail5 <andrew@rail5.org>  Fri, 02 May 2025 20:36:34 +0800

bpp (0.3.8) unstable; urgency=medium

  * Treat constructors and destructors as ordinary methods
    Prior to this, constructors and destructors were treated specially
    Now, they're treated as ordinary methods which are always VIRTUAL
    and PUBLIC. This simplifies things and fixes a few bugs, namely:
    Before this change, instantiating an object of class A, and copying
    its address to a pointer of class B (which is allowed in Bash++),
    and then later calling @delete on the B pointer, would have called
    B's destructor if it had one. This is clearly incorrect behavior
    Ensuring that the destructor is virtual forces this to do a vtable
    lookup, guaranteeing that we call the correct destructor regardless
    of the compile-time inferred type.
    Further, before this change, defining a constructor or destructor
    within a base class would preclude the possibility of implementing a
    separate constructor or destructor in a derived class.
    Now that constructors and destructors follow the rules for ordinary
    methods (and are virtual), no special logic is necessary in order to
    override them in derived classes.
    Base class constructors and destructors are still inherited in
    derived classes by default.
  * Object instantiations:
    Verify that the desired class exists earlier rather than later
    Fixes a segfaulting bug
  * New statements: call constructors before returning the pointer
    Ensure that objects which have not yet been constructed are not
    processed too early

 -- rail5 <andrew@rail5.org>  Wed, 30 Apr 2025 18:44:52 +0800

bpp (0.3.7) unstable; urgency=medium

  * Test-suite: Added test for nonprimitive copies
  * value_assignment: always get address directly from rvalue_object,
    do not infer (fixes bug with nonprimitive copies)
  * Dereference pointers at runtime
    Has strong potential to reduce compiler complexity
  * Make pointer declarations within methods local by default

 -- rail5 <andrew@rail5.org>  Sun, 27 Apr 2025 17:03:09 +0800

bpp (0.3.6) unstable; urgency=medium

  * Method handler: Move sanity checks to entry rule
    This allows us to skip parsing invalid methods
    (non-public toPrimitive, or duplicate method definitions),
    saving time
    Adding the method to the class before parsing its contents
    also allows methods to refer to themselves, which is necessary
    for recursive methods

 -- rail5 <andrew@rail5.org>  Sat, 26 Apr 2025 13:53:57 +0800

bpp (0.3.5) unstable; urgency=medium

  * Proper support for c-style arithmetic Bash for loops
  * More sane handling of bash arithmetic statements
  * Proper support for bash number ranges '{#..#[..#]}' 
  * Compiler source code cleanup:
    Made bpp_method's 'add_object_as_parameter' private
    Externally we should only ever call add_parameter, which should
    determine whether the parameter is nonprimitive on its own

 -- rail5 <andrew@rail5.org>  Fri, 25 Apr 2025 22:41:37 +0800

bpp (0.3.4) unstable; urgency=medium

  * Allow taking the address of an object's method
    Return value of &@object.method should be:
    - A function pointer to the method
    - Plus the object pointer as the method's implicit first parameter
    E.g, 'echo &@object.method' should echo something like
    'bpp__Class__method address__of__object'
  * Incidental bug fix: vTable lookups in rvalue self references.
    Patched by properly using the abstracted generate_method_call_code
    function rather than duplicating its functionality. The duplicate
    code was a relic from before that abstracted function existed and
    should've been noticed and patched out sooner
  * Parser speedup
    Removed left-side ambiguity between member declarations and method
    definitions by enclosing them in a shared parent rule
    A total rewrite of the lexer/parser is almost definitely incoming

 -- rail5 <andrew@rail5.org>  Tue, 22 Apr 2025 14:14:53 +0800

bpp (0.3.3) unstable; urgency=medium

  * Skip comments directly in the lexer
    Significant overall speedup.
    Heavily considering a total rewrite of the ANTLR lexer/parser
  * Made list of protected keywords constexpr
    Improves performance, list doesn't have to be initialized at runtime 

 -- rail5 <andrew@rail5.org>  Wed, 02 Apr 2025 15:28:59 +0800

bpp (0.3.2) unstable; urgency=medium

  * Builds: Only search for dynamic libs if static libs can't be found
  * Run an implicit dynamic cast when a method takes a non-primitive
    argument
  * Abstracted dynamic cast code generation to its own function

 -- rail5 <andrew@rail5.org>  Sat, 22 Mar 2025 15:11:17 +0800

bpp (0.3.1) unstable; urgency=medium

  * Keep object counter in compiler
    This closes #6, although the allocations are not randomized at
    runtime. This decision may be revisited later
    An incidentally necessary change for this fix is that the 'isPtr'
    nonsense from templates.h had to be removed entirely, methods
    internally must accept a pointer as the first argument and no extra
    information, just as in C++ for example

 -- rail5 <andrew@rail5.org>  Wed, 19 Mar 2025 11:46:23 +0800

bpp (0.3.0) unstable; urgency=medium

  * Proper vTable implementation
    This ensures that we call the correct versions of virtual methods
    at runtime. This was planned, but previously unimplemented
  * Added '@dynamic_cast' keyword for runtime type checking,
    @dynamic_cast<Type> @pointer
    Will perform a runtime check to verify the cast is valid, and will
    return @nullptr if invalid.
  * Added -s / --no-warnings option to suppress compiler warnings

 -- rail5 <andrew@rail5.org>  Thu, 06 Mar 2025 17:50:17 +0800

bpp (0.2.8) unstable; urgency=medium

  * Test suite: run tests concurrently
  * Major bug fix: Supershells
    Stupid oversight in previous patch caused us to stop using shm and
    file descriptors altogether
    Using /dev/fd. This directory is not guaranteed by POSIX, but far
    more portable than /proc/self/fd
    This breaks compatibility with MacOS and Haiku
  * Bug fix in pointer declarations: Verify current_datamember isn't
    nullptr before accessing its method
  * Build system: Compile and link separately for faster builds with
    concurrency
  * Bug fix: properly handle assignment prefixes before commands
    The lexer should recognize that in a command like
    'var=val command args'
    'var' and 'command' are both lvalues (as per our unusual definition
    of 'lvalue')
  * Build system: Merged pull request #5 from wishdev/touchups
    Common-sense repository touch-ups. Removing auto-generated header
    file, adding gitignore, improved makefile workflow

 -- rail5 <andrew@rail5.org>  Sat, 01 Mar 2025 14:52:08 +0800

bpp (0.2.7) unstable; urgency=medium

  * Removed 'Array' class from STL
    This functionality is really already served by Bash primitive arrays
    Adding non-primitive object arrays would be nice however
  * Bug fix: We'll always have to dereference a pointer if the first
    object in a reference chain is a pointer
    Object references should still be reworked altogether
  * Added test to verify correct exit codes from run-on-exit
  * Pass compiler path to tests in the test suite
    If we want to run another instance of the compiler from within a test,
    we can access it via the $BPP environment variable
  * Portable solution to the problem with inconsistent WEXITSTATUS
    behavior across different systems
  * Portability: Do not assume the presence of /proc/self

 -- rail5 <andrew@rail5.org>  Mon, 24 Feb 2025 15:24:22 +0800

bpp (0.2.6) unstable; urgency=medium

  * Case patterns: Inherit directly from code entities
  * Code entities: Return line buffers by default in get_pre_code
    and get_post_code
  * Make sure we place the pre- and post- code for case headers and case
    rules in the right places
    Pre/post code for case headers should go before/after the entire
    case statement
    Pre/post code inside case rules should go in the usual places
  * Ensure each assignment temporary rvalue has a unique identifier

 -- rail5 <andrew@rail5.org>  Mon, 17 Feb 2025 02:01:02 +0800

bpp (0.2.5) unstable; urgency=medium

  * Changed a few internal_errors to syntax_errors
    An internal error should only be thrown if we encounter something
    that shouldn't be possible
  * More helpful internal errors
    Provide the text of the parse tree where we hit the internal error
  * Better syntax error reporting
    In some cases, ANTLR mistakenly reports token positions as line 0
    column -1 In those cases, we should say that the position is not
    known to us instead of trying to display that portion of the file

 -- rail5 <andrew@rail5.org>  Sun, 16 Feb 2025 18:01:29 +0800

bpp (0.2.4) unstable; urgency=medium

  * Patch: Properly evaluate supershells before & after while loops
  * -t option should exit early if all we're doing is displaying the
    tokens.

 -- rail5 <andrew@rail5.org>  Sun, 16 Feb 2025 01:09:46 +0800

bpp (0.2.3) unstable; urgency=medium

  * Considerable speed increase
    Attempting to slightly refactor the lexer/parser to remove ambiguity
    and reduce our dependence on ANTLR's lookahead and backtracking

 -- rail5 <andrew@rail5.org>  Sat, 15 Feb 2025 17:34:15 +0800

bpp (0.2.2) unstable; urgency=medium

  * Override add_object within code_entity base class
    Every code entity should be able to add object code, not only add a
    reference to the object internally
    This removes a lot of silly code duplication which took place in
    classes derived from code_entity
    And, incidentally, closes #3
  * Properly parse 'for' loops

 -- rail5 <andrew@rail5.org>  Sat, 15 Feb 2025 13:41:16 +0800

bpp (0.2.1) unstable; urgency=medium

  * Fixed #4:
    Do not emit the 'connective' token in contexts in which the
    connective symbol should be interpreted as a literal
    Also recognize a solitary pipe as a valid connective

 -- rail5 <andrew@rail5.org>  Fri, 14 Feb 2025 16:13:13 +0800

bpp (0.2.0) unstable; urgency=medium

  * Added a small standard library to store common data structures
    This standard library will be provided by the libstd-bpp package
    Which package will be a dependency of bpp
    Standard library has for now: Array, Stack, Queue
  * Added option for dynamic linking (-D) in the compiler
    If dynamic linking is enabled, the code from @include'd files will
    Not be copied into your compiled file, but instead, your compiled
    Program will contain a Bash "source" directive pointing to the
    Compiled version of the dynamically linked library, linking it at
    Runtime.
    If you dynamically link an included file such as:
    /usr/lib/bpp/stdlib/Stack.bpp
    Your compiled program will expect to be able to find at runtime:
    /usr/lib/bpp/stdlib/Stack.sh
  * Added support for angle-bracket includes and compiler include paths
    A Bash++ directive such as @include <file> will scan the include
    Paths for the given file.
    The default include path is /usr/lib/bpp/stdlib
    More include paths can be added with the -I option in the compiler
    Include paths will be searched in the order in which they are added
  * Properly parse Bash while loops
  * @new properly returns a pointer (thanks to supershells)
  * Patch: Ensure methods and datamembers don't share names

 -- rail5 <andrew@rail5.org>  Thu, 13 Feb 2025 19:33:29 +0800

bpp (0.1.1) unstable; urgency=medium

  * Patch: Override get_code methods in bash_if_branch
    The base code_entity version of these methods return empty strings
    for pre-and post-code buffers
    This broke if statements that weren't split across multiple lines,
    and therefore never caused the code buffers to be flushed
  * Patch: Add stray terminal tokens to program

 -- rail5 <andrew@rail5.org>  Wed, 12 Feb 2025 22:25:09 +0800

bpp (0.1) unstable; urgency=medium

  * Initial release
    Bash++ is still considered to be in beta (or alpha, take your pick)
    And is expected to break often and have many bugs.
    Please report any bugs you find to the GitHub issue tracker:
    https://github.com/rail5/bashpp/issues

 -- rail5 <andrew@rail5.org>  Wed, 12 Feb 2025 20:09:39 +0800
